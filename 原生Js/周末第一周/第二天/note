1.面向对象的特点：
1）封装：低耦合，高内聚;--把功能相同的代码，只写一次并且封装好，以后再使用，直接调用即可，无需再重写；
2）继承：子类可以继承父类的属性和方法；
3)多态：重载 和 重写
重载：JS不存在严格意义的重载，如果非要说JS有重载，只能说他有类似重载的功能：给同一个函数，传不同的参数，可以实现不同的效果；
重写：子类可以重写父类的属性和方法；
2.JS的常见的四个设计模式：单例模式，工厂模式，构造函数模式，原型模式
3.单例模式：把描述同一对象的属性和方法，都放在同一个命名空间下；
命名空间:把描述同一对象的属性和方法，放在同一个空间下，给这个空间起个名字：例如person1就叫做命名空间；
单例的本质：普通对象
4.模块化开发：就是把一个大型项目，分配给不同的工程师，进行同步开发，等所有人都开发完成后，进行项目合并，经测试无误，上线；
5.单例模式是最简单的模块化开发：--未来的DOM库用的就是单例模式开发
1）不同模块间的相互调用：模块名.属性名
2）本模块之间的相互调用：this.属性名
6.单例模式的优缺点：
优点：
1)避免全局变量的冲突和污染
2）是最简单的模块化开发
缺点：属于传统的手工作业模式，开发效率低，存在大量的冗余代码；
解决措施：封装--工厂模式
7.工厂模式-3步骤：
1）引进原材料              1）创建一个空对象
2）对原材料进行加工和处理    2）给空对象添加属性和方法
3）输出原材料              3）输出对象
工厂模式的本质：封装；
8.工厂模式跟构造函数模式的区别：
1）在调用的时候：
    1）工厂模式直接就是函数名()，函数名的首字母小写，构造函数模式，函数名的首字母大写；
    工厂模式返回的也是对象，但他不叫实例；
    2)工厂模式无new; 构造函数有new
    注意：构造函数new 出来的都是实例、对象；
2）函数内部的区别：
    1）工厂模式有3步：1.创建空对象 2.给对象添加属性和方法 3.输出对象
    2）构造函数模式有1步：给对象添加属性和方法；因为系统默认为我们做了1,3这两步；
9.构造函数模式的目的：为了创建自定义的 类，通过自定义的类去new 出很多 实例；
构造函数需要注意的6个小细节：--非常重要
1）构造函数就是 实例 和 类 打交道；√
2）构造函数中的this都是new出来的实例；√
3）构造函数new 出来的实例，只跟this.xxx有关，跟函数中的变量没有任何关系
4）系统会自动帮我们返回对象this，我们如果非要手动返回的话：
    1.手动返回的是基本数据类型：对实例没有任何影响；
    2.手动返回的是引用数据类型(对象)：以前实例身上的属性和方法就无效了；
5)构造函数中存放的都是私有属性和方法； √
6）构造函数调用的时候，如果没有参数，小括号可以省略；
10.构造函数中存放都是：私有的属性和方法
原型prototype上存放的都是：公有的属性和方法；
11.构造函数的原型模式（原型模式）：
原型模式：跟 （实例，类，原型）  打交道
12.原型模式的基础知识：3句话：
1）每个函数身上，都有一个 属性，叫做prototype,prototype是个对象；
2)prototype这个对象上，天生自带一个属性，叫做constructor：当前这个类；
3）每个对象身上，都有一个属性，叫做__proto__:当前实例所属类的原型；
13.原型链查找机制：
如果想查找 对象.属性名
1）现在自己的私有属性上进行查找，找到，说明是私有属性
2）如果没找到，通过__proto__去当前实例所属类的原型上一级级的查找，找到，说明是公有属性
3）如果没找到，继续通过__proto__一级级的往上查找，找到Object.prototype上还没有的话，返回undefined；
14.批量添加和修改公有方法：
“注意”：系统内置类，无法通过对象 批量修改 系统内置类的公有方法，这是出于浏览器的自我保护；
但是我们可以 一个个的去修改 系统内置类的公有方法；

另外，我们给自定义类批量添加公有属性和方法，都是通过 自定义类.prototype={};进行添加的，只是需要“注意”：constructor的指向；
15.在IE浏览器下，浏览器支持__proto__去查找和修改公有属性和方法，但是禁止用户使用__proto__;这也是出于浏览器的自我保护；那我们可以通过:类.prototype去修改和使用公有方法；也可以通过 实例.属性名 去使用公有方法；
16。Object 是所有类的基类；
17.Object.prototype:
obj.hasOwnProperty(属性名):判断是否为私有属性
obj1.isPrototypeOf(obj2):判断前一个对象是否在后一个对象的原型链上；
propertyIsEnumerable：判断是否为可枚举的属性：
toString:用来数据类型检测的；
18.链式操作：
能否进行链式操作，取决于你前面函数的返回值：
返回值是数组，能使用数组的方法；
返回的是数字，只能使用数字的方法； toFixed(要保留的小数个数)
19.面向对象的继承：
1）call继承:把父类私有的属性和方法，都继承给了子类私有的属性和方法；
2)原型链继承：把父类 私有+公有 的属性和方法，都继承给了子类 公有的 方法；
3）冒充继承：把父类 私有+公有 的方法，都继承给了子类 私有的属性和方法；
4）混合继承：call继承+原型链继承
    call继承：父类私有 给了 子类私有
    原型链继承：父类私有+公有 给了 子类公有
    问题：父类私有的即给了 子类私有的； 也给了子类 公有的；
5）混合继承：call继承+拷贝继承
    call继承：子类构造函数中通过call继承父类私有的；
    拷贝继承：for in :让子类公有 去拷贝 父类公有;

6）混合继承：寄生式组合继承；
call继承+object.create()思想的继承;
    //call继承+ 原型链继承过滤；-去除父类私有的；












