1.为什么要学习预解释
1）理解i值在不同情况所代表的值；
2）带var 和 不带 var 的区别；
3）学习预解释，可以让我们知道为何正确，为何错误；--规范我们的书写习惯
2.什么叫预解释：
在当前作用域下，在JS代码执行之前，我们会对带var或带function的进行声明或定义；
声明：就是告诉浏览器有这么一个变量； var a;
定义：对已经声明过的变量，进行赋值； a=123;
3.带var或带function的预解释不同：
带var：只声明不定义
带function：声明+定义
4.函数定义和调用
定义3阶段
    1.开辟一个空间地址 xxff00;
    2.把函数体内的所有代码，做为字符串存在这个空间中
    3.把空间地址赋值给函数名；

函数调用有4步骤：
    1.形成一个私有作用域
    2.形参赋值
    3.预解释-条件反射：带var和带function的进行声明或定义
    4.JS代码从上倒下的执行；
作用域链：当函数被调用的时候，形成一个私有作用域，在这个私有作用域中是否存在私有变量N;
1)如果有私有变量N：说明该函数中的所有变量N，都是私有变量，跟外界就没有任何关系了；
2）如果没有私有变量N：去上级作用域进行查找，如果没找到，继续去上级的上级作用域进行查找，一直找到全局作用域window下还没有的话，报错！
5.什么是上级作用域：
上级作用域跟函数在哪里调用没有关系，只跟函数对应的堆内存在哪里开辟有关；
6.内存：栈内存 和 堆内存
栈内存：作用-提供了一个供JS代码执行的环境： 全局作用域 和 私有作用域
        栈内存中也可以放数据，但他放的是基本数据类型的值；
        var a='123dsfsdfsdfsdfsdfsfe'
堆内存：作用-用来保存引用数据类型的数据的；
        对象：在堆内存中保存的是属性和属性值；
        函数：代码字符串；
        var o={obj1:'lsdkfjsldkfjlskdfjldskdfjlskfjlskfjlsdfkjfsljk',obj2:xxx,obj3:xxx,..........}
        function fn(){
            lskdjflskjdflskjflskdfjlskdjfskjf
        }
7.私有变量只有两种：
1)函数中带var的
2)形参
8.预解释无节操：
1）只会对=左边的进行声明，但不定义
2）自执行函数不会进行预解释，只有等执行到他的时候，才会声明+定义+调用同步完成
3）无论条件是否成立，都会进行预解释--IE浏览器下
4）已经声明过的变量，不会进行重复声明
5）return后面的语句，不会进行预解释； return下面的语句虽然不执行，但会进行预解释；
9.带var 和不带var的区别：
带var：会进行预解释；在全局作用域下，属于全局变量；
不带var：不会进行预解释;属于全局变量；
10.this小总结：
1）当元素身上的行为或事件被触发的时候，会调用一个函数，函数中的this指向当前这个元素；
obj.onclick=function(){
    alert(this)
}
2）当函数被调用的时候，看前面是否有点.,点.前面是谁，this就是谁；fn(); obj.fn()
3）自执行函数中的this，永远都是window；(function(){})();
11.内存释放：
堆内存释放： 对象  var b=xxff00;
           函数  var fn=xxff00;
           b=null; fn=null;
          我们让以前被变量占用的内存地址如果想释放，就让变量指向空指针，这样，等浏览器空闲的时候，就会把没有被占用的内存空间，当作垃圾回收；浏览器的这种回收机制，叫做垃圾回收机制；
栈内存： 全局作用域 和 私有作用域
全局作用域：关闭页面的时候得到释放；
私有作用域：一般情况下，当函数执行完成的时候会立即释放；
    特殊不释放的情况有两种：
    1）函数中的东西被外面的变量或者其他占用的话，就无法释放；
    2）不立即释放；
    function fn(){
        return function(){
            alert(a)
        }
    }
    fn()();
12.|| &&
||:前面为假，才会走后面
&&：前面为真，才会走后面
13.关于运算符的优先级：
算术>比较>逻辑>赋值
14.return 返回值：
return为undefined:
    1)没有写return
    2）写了return但没有赋值
return作用：
    1）返回值
    2）阻断程序执行的作用；
15.闭包的作用：
1.避免全局变量的冲突、污染；
2.封装
事件绑定：
1）标准浏览器用addEventListener








