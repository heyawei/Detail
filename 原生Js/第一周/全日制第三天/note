1.对象的特点：属性 和 方法
2.面向对象的特点：
    1）封装：把相同功能的代码，只写一次，并且封装起来，以后再用，直接调用即可；（低耦合，高内聚）
    2）继承：子类可以继承父类的属性和方法；
    3）多态：重载 和 重写
    重载：JS上没有严格意义的重载，如果非要说JS有重载，只能说他有类似重载的功能：传不同的参数，可以实现不能的功能；
    重写：子类可以重写父类的属性和方法；--原型链继承；
3.单例模式：把描述同一对象的属性和方法，放在同一个命名空间下；这样避免了全局变量的冲突；
命名空间：把描述同一对象的属性和方法都放在一个内存空间下，我们给空间地址起的名字：例如person1就是命名空间；
单例模式的本质：普通对象；
4.单例模式的优缺点：
优点：
    1.避免了全局变量的冲突
    2.它是最简单的模块化开发；
        模块化开发：对于一个工程，公司会分配给不同的人，去同步开发，等开发结束的时候，把所有人开发的模块合并起来；就完成了整个项目；
        单例模式就是最简单的模块化开发：
        1）实现模块之间的相互调用：模块名.属性名
        2）本模块之间的相互调用：this.属性名；
缺点：对于同一个功能，返回被写在不同的模块空间中，造成大量冗余的代码；
5.工厂模式：
    工厂模式的本质：就是封装
    工厂模式3步骤：
    1）批发一批原材料    ---  创建一个空对象
    2）对原材料进行加工  ---   给空对象添加属性和方法
    3）把产成品输出     --    输出对象；
6.如果想让工厂模式的调用方式 跟 系统函数的调用方法一样；
需要修改两个地方：
1）函数的调用的时候，前面+new； //再也不需要手动创建和返回对象了
2）函数的函数名首字母大写；--没影响
7.构造函数模式：作用--就是用来封装一个类，并且可以通过这个类new出实例；
比如系统的类； var ary=new Array();
构造函数，就是 实例 和 类 在打交道；
8.构造函数模式 跟 工厂模式有哪些区别？
    1）在函数调用的时候：
        工厂模式，直接 函数名();
        构造函数，new 函数名()；注意：函数名首字母大写；
    2）在函数内部的区别：
        工厂模式有三步：1.创建对象 2.给对象添加属性和方法 3.输出对象
        构造函数有1步：只是给对象this添加属性和方法
            系统默认会为我们创建好对象，并且，最后默认为我们返回对象；
9.构造函数的问题：
    对于同一个功能，却不相等；p1.fn !==p2.fn; 因为这些功能，都是对象私有方法；
    解决措施：把功能相同的代码，放在原型prototype上；
10.构造函数总结：
    1）构造函数中的this都是当前new出来的这个实例；
    2）构造函数创建的实例，只跟this.xxx有关，跟变量没有关系
    3）构造函数中存放的都是私有的属性和方法；
    4）构造函数系统默认会为我们返回一个对象，不建议手动返回：
        如果自己手动返回：
        1）返回的是基本数据类型；不会有任何效果
        2）如果返回的是对象类型；那么以前实例身上的属性和方法都没用了；
    5）构造函数调用的时候，如果没有参数，小括号可以省略；
    6)构造函数就是实例 和 类 打交道；
11.原型模式的基础知识：
    1）每个函数（普通函数，构造函数），都有一个prototype属性，它是一个对象；
    2）prototype这个对象上，天上自带一个属性，叫做constructor,指向当前所属的类；
    3)每个对象（普通对象，实例，原型）身上，都有一个属性，叫做__proto__，指向当前实例，所属类的原型；
12.原型链：核心通过：__proto__ 在查找；
如果想查找 对象.属性名;
1)现在自己的私有空间中进行查找；找到--说明它是私有属性
2）找不到的时候，通过__proto__继续去当前实例所属类的原型上进行查找；找到--说明它是公有属性
3）找不到，继续通过__proto__一层层的往上找，找到Object.prototype上都没有，就返回undefined;
13.条件反射：
1）一提到构造函数：构造函数中存的都是私有的属性和方法；
2）一提到prototype原型：原型上都存的是公有的属性和方法；
3）一提到__proto__:说明他是原型链；所有的属性和方法，都通过原型链__proto__进行查找的；
14.Object.prototype上的公有方法：
1）obj.hasOwnProperty(attr):判断是否为私有属性
2）obj1.isPrototypeOf(obj2);obj1是否在obj2的原型上
3）propertyIsEnumerable:是否可枚举的属性
4）toString //下周讲
Object.prototype.toString.call()
15. in 判断是否为元素身上的属性：私有+公有属性
16.批量修改元素的公有属性和方法？
    给当前元素所属类的原型上，重新赋值一个对象{};但这里一定没有constructor;需要手动添加constructor:当前这个类；
17.浏览器拒绝批量修改内置对象的公有属性，但是我们可以一个个的修改；
    IE浏览器，有__proto__这个属性，但是拒绝用户直接操作__proto__;
18.fn.call(obj,1,2);
   作用：把call前面的函数中的this关键字，改为call的第一个参数
   call的第二个参数开始，就相当于给fn中的参数从左往右一个个的赋值；
19.关于继承：
1）call继承核心：把父类的私有属性和方法，做为子类私有的属性和方法；
      说明：子类只继承了父类私有的属性和方法；跟父类公有的属性和方法无关
2）原型链继承：把父类私有和公有的方法，都作为子类公有的方法；
    说明：把父类私有和公有的方法，都放在子类的原型prototype上；
    子类原型=父类的实例；