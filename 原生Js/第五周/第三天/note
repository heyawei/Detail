 3e1.DOM0级和DOM2级的区别：
    1）DOM0身上，都是元素身上的私有属性；例如：‘onclick’私有属性
       DOM0只能发生在事件流的冒泡阶段
       在DOM0级事件中，如果同一个元素身上，同一个行为，绑定多个不同的方法，后面的方法会覆盖前面的方法；
    2）DOM2级：
        1）在元素的eventTarget这个类的原型上；所以，他是公有
        标准浏览器：addEventListener(type,fn,false);
        2）DOM2级可以发生在事件流的两个阶段：捕获 和 冒泡；
        3）DOM2级事件中，同一个元素身上，同一个行为，可以绑定多个不同的方法；
2.DOM2级事件
    1）标准浏览器：
        绑定事件：obj.addEventListener(type,fn,false);
        解除绑定:obj.removeEventListener(type,fn,false)
    2)IE浏览器：
        绑定事件：obj.attachEvent('on'+type,fn);
        解除绑定：obj.detachEvent('on'+type,fn)
3.解除事件绑定，只能解除有名字的函数；匿名函数无法解除事件绑定；
true:捕获false：冒泡。先冒泡后捕获
阻止冒泡兼容处理：e.stopPropagation?e.stopPropagation():e.cancelBubble
4.在标准浏览器的DOM2级事件中：
    1）按顺序执行：当行为被触发的时候，被绑定的方法，按顺序执行；
    2）没有重复问题：同一个元素，同一个行为，绑定相同的方法，就算绑定多次，也只会执行一次
    3）this指向被触发行为的这个元素oDiv；
 在IE的DOM2级事件中：attachEvent
    1）顺序有问题
    2）重复绑定问题；
    3）this指向window；this也有问题
5.DOM2级事件绑定和解除兼容问题；
事件对象：保存了当前行为的详细信息：{type：‘click’，}
冒泡的典型利用：--事件委托
事件委托：如果
6.event事件库的思路：
    1）浏览器的兼容处理：
        标准：addEventListener
        IE：attachEvent;
    2)处理this问题：
        1）把要绑定的每个方法，都放在一个匿名函数中，并且，通过call更改了每个方法的this指向问题；
        var fnTemp=function(){fn1.call(ele)}
        2)把每个fnTemp都放进自己事件池和系统事件池；但因为他们都叫fnTemp，所以，为了以后可以解除事件绑定，我们给每个fnTemp都起了名字fnTemp.name=fn1;
        解除事件绑定的时候，只需要循环数组，找到要解除的函数的名字，然后解除他；（注意：既要解除系统事件池，也要解除自己事件池；）
    3）处理去重问题：
        在把每个fnTemp放进自己事件池和系统事件池之前，都进行去重的判断，如果已经重复，直接阻断程序执行；-》实际就是不往自己事件池和系统事件池中放；
    4）处理同一个元素，不同行为，绑定相同方法的问题；
        措施：给元素的自定义属性上，不同的行为，创建不同的数组来存储该行为下不同的方法；
        ele['aEvent'+type]
    5)解决顺序问题：
        1）把所有要绑定方法，都放到自己事件池中；（自己事件池就是一个数组）；
        2）给系统事件池中，只绑定一个run方法；run方法要做的事情：就是当行为被触发的时候，把自己事件池中该行为下保存好的所有方法，进行顺序调用；
///////////////////////////////////////////////////













